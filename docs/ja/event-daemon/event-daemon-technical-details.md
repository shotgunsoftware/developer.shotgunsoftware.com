---
layout: default
title: 技術の詳細
pagename: event-daemon-technical-details
lang: ja
---

# 技術的な概要

<a id="Event_Types"></a>

## イベント タイプ

トリガを登録して通知するイベント タイプは、通常、次の `Shotgun_[entity_type]_[New|Change|Retirement|Revival]` 形式を使用します。以下に、この形式の例をいくつか示します。

    Shotgun_Note_New
    Shotgun_Shot_New
    Shotgun_Task_Change
    Shotgun_CustomEntity06_Change
    Shotgun_Playlist_Retirement
    Shotgun_Playlist_Revival

エンティティの記録アクティビティには関連せず、アプリケーション動作のキー ポイントに関連するイベントに対しては、これらの通常の形式とは異なるものが使用されます。

    CRS_PlaylistShare_Create
    CRS_PlaylistShare_Revoke
    SG_RV_Session_Validate_Success
    Shotgun_Attachment_View
    Shotgun_Big_Query
    Shotgun_NotesApp_Summary_Email
    Shotgun_User_FailedLogin
    Shotgun_User_Login
    Shotgun_User_Logout
    Toolkit_App_Startup
    Toolkit_Desktop_ProjectLaunch
    Toolkit_Desktop_AppLaunch
    Toolkit_Folders_Create
    Toolkit_Folders_Delete

このリストはすべてを網羅しているわけではありませんが、糸口にしてください。{% include product %} サイトのアクティビティやイベントのタイプに関する詳細を確認したい場合は、他のエンティティ タイプの他のグリッド ページのようにフィルタや検索が可能な EventLogEntries のページを参照してください。

### サムネイルのイベント ログ エントリ

エンティティの新しいサムネイルをアップロードすると、`` `Type` == `Shotgun_<Entity_Type>_Change` `` でイベント ログ エントリが作成されます(例: `Shotgun_Shot_Change`)。

1. `‘is_transient’` フィールドの値は true に設定されています。

```
{ "type": "attribute_change","attribute_name": "image",
 "entity_type": "Shot", "entity_id": 1286, "field_data_type": "image",
 "old_value": null, "new_value": 11656,
 "is_transient": true
}
```

2. サムネイルが使用できるようになると、`‘is_transient’` フィールドの値が false に設定された新しいイベント ログ エントリが作成されます。

```
{ "type": "attribute_change", "attribute_name": "image",
 "entity_type": "Shot", "entity_id": 1286, "field_data_type": "image",
 "old_value": null, "new_value": 11656,
 "is_transient": false
}
```

3. サムネイルをもう一度更新すると、次のような新しいイベント ログ エントリが取得されます。

```
{ "type": "attribute_change", "attribute_name": "image",
 "entity_type": "Shot", "entity_id": 1286, "field_data_type": "image",
 "old_value": 11656, "new_value": 11657,
 "is_transient": true
}
{ "type": "attribute_change", "attribute_name": "image",
 "entity_type": "Shot", "entity_id": 1286, "field_data_type": "image",
 "old_value": null, "new_value": 11657,
 "is_transient": false
}
```

4. 添付ファイルのサムネイルがプレースホルダのサムネイルである場合、`‘old_value’` フィールドは null に設定されることに注意してください。

<a id="Plugin_Processing_Order"></a>

## プラグインの処理順序

各イベントは常に同じ予測可能な順序で処理されるため、プラグインやコールバックが共依存している場合は、処理を支障なく整理することができます。

環境設定ファイルで、1 つまたは複数のプラグインの場所を含む `paths` 設定を指定します。リスト内での順番が早い場所ほど、含まれているプラグインが早く処理されます。

プラグイン パス上の各プラグインは、アルファベットの昇順で処理されます。

{% include info title="注" content="内部処理として、ファイル名がリストに登録されてソートされます。"%}

最終的に、プラグインによって登録された各コールバックが登録順に呼び出されます。最初に登録されたコールバックが、最初に実行されます。

1 つまたは複数のコールバックと同じプラグインで状態を共有する必要がある機能を保持することをお勧めします。

<a id="Sharing_State"></a>

## 状態を共有する

状態を共有する必要がある複数のコールバックに設定できる多くのオプションがあります。

- グローバル変数。これは適切ではありません。使用しないでください。
- 読み込んだモジュール。状態の情報を保持します。適切ではありませんが、単純なグローバル変数よりは適しています。
- [`Registrar.registerCallback`](API#wiki-registerCallback) を呼び出すときに `args` 引数で渡される可変値。設計の状態オブジェクト、または `dict` のような単純な関数。推奨します。
- オブジェクト インスタンスで `__call__` などのコールバックを使用して、コールバック オブジェクトの初期化時に共有状態オブジェクトをいくつか指定します。最も強力な方法ですが、最も複雑な方法でもあります。上記の args 引数メソッドと比較すると、煩雑になる場合があります。

<a id="Event_Backlogs"></a>

## イベント バックログ

フレームワークの仕様により、すべてのプラグインは、対象のすべてのイベントそれぞれを例外なく 1 回のみ処理します。必ずこのように処理されるように、フレームワークは各プラグインの未処理イベントのバックログを保存し、各プラグインが提供された最後のイベントを記憶します。バックログが発生する可能性のある状況は、以下のとおりです。

### イベント ログ エントリ シーケンスのずれによるバックログ

{% include product %} で発生する各イベント(フィールド更新、エンティティの作成、エンティティの廃棄など)には、そのイベント ログ エントリの一意の ID 番号が割り当てられます。ID 番号シーケンスにずれが生じることがあります。このようなずれは、大規模なデータベース トランザクションが完了していない場合など、さまざまな理由で発生する可能性があります。

イベント ログ シーケンスにずれが生じると、「不明」なイベント ID はバックログに記録され、後で処理されます。これにより、イベント デーモンは、時間がかかるデータベース トランザクションの終了後に、このようなイベントを処理できます。

トランザクションが失敗した場合やページ設定の変更を元に戻した場合など、イベント ログ シーケンスのずれを埋められない場合もあります。この場合、5 分のタイムアウト後に、イベント ログ エントリの ID 番号の割り当て待機は停止され、バックログから削除され、「バックログのイベント ID 番号のタイムアウト時間が経過しました」というメッセージが表示されます。イベント シーケンスのずれが初めて発生し、既にタイムアウト時間が経過したと判断された場合、「イベント番号は割り当てられません: 無視されます」というメッセージが表示され、そもそもバックログに記録されません。

### プラグイン エラーによるバックログ

通常の操作中、フレームワークは常に各プラグインによって処理された最後のイベントをトラッキングします。何らかの理由でプラグインが処理に失敗した場合、以降のイベントの処理は停止されます。バグの修正などによってプラグインを修正すると、フレームワークは、修正されたプラグインに保存された最後のイベントでイベントの処理を開始します。これにより、修正されたプラグインが、エラーが発生してから修正するまでの過去に発生したイベントなど、すべてのイベントを確実に処理できます。エラーがかなり前に発生した場合は、多くのイベントをやり直す必要があり、修正したプラグインが、正常に機能していた他のプラグインの処理に追い付くまでにしばらく時間がかかる可能性があります。

修正したプラグインが遅れを取り戻している間、他のプラグインはこれらのイベントを無視し、同じプラグインで 1 つのイベントが 2 回処理されないようにします。その場合、「イベント X は古いイベントです。最後に処理されたイベントは(Y)です」というメッセージが表示されます。これはデバッグ メッセージです。無視しても問題ありません。

このメッセージの表示を回避する正式な方法はありません。フレームワークの仕様により、すべてのプラグインそれぞれは、すべてのイベントを 1 回のみ処理します。ただし、Python とその pickle データ形式に慣れている場合は、デーモンを停止し、Python インタプリタ/インタラクティブ シェルで .id ファイルを開き、pickle モジュールで内容をデコードし、保存されている ID を削除して内容を編集します。このようにして、作成されているバックログを省略できます。この操作はサポートされていないため、ご自身の責任において行ってください。この操作を行う場合は、まず `.id` ファイルを適切にバックアップしてください。
